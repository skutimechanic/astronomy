//
// AUTO-GENERATED FILE, DO NOT MODIFY!
//

import 'package:built_collection/built_collection.dart';
import 'package:openapi/src/model/dj_subscriptions_proration_behavior.dart';
import 'package:openapi/src/model/dj_subscriptions_plan.dart';
import 'package:openapi/src/model/dj_subscriptions_price.dart';
import 'package:openapi/src/model/status_enum.dart';
import 'package:openapi/src/model/collection_method_enum.dart';
import 'package:built_value/built_value.dart';
import 'package:built_value/serializer.dart';

part 'patched_dj_subscriptions.g.dart';

/// PatchedDJSubscriptions
///
/// Properties:
/// * [djstripeId] 
/// * [plan] 
/// * [price] 
/// * [canReactivate] 
/// * [djstripeCreated] 
/// * [djstripeUpdated] 
/// * [id] 
/// * [livemode] - Null here indicates that the livemode status is unknown or was previously unrecorded. Otherwise, this field indicates whether this record comes from Stripe test mode or live mode operation.
/// * [created] - The datetime this object was created in stripe.
/// * [metadata] - A set of key/value pairs that you can attach to an object. It can be useful for storing additional information about an object in a structured format.
/// * [description] - A description of this object.
/// * [applicationFeePercent] - A positive decimal that represents the fee percentage of the subscription invoice amount that will be transferred to the application owner's Stripe account each billing period.
/// * [billingCycleAnchor] - Determines the date of the first full invoice, and, for plans with `month` or `year` intervals, the day of the month for subsequent invoices.
/// * [billingThresholds] - Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period.
/// * [cancelAt] - A date in the future at which the subscription will automatically get canceled.
/// * [cancelAtPeriodEnd] - If the subscription has been canceled with the ``at_period_end`` flag set to true, ``cancel_at_period_end`` on the subscription will be true. You can use this attribute to determine whether a subscription that has a status of active is scheduled to be canceled at the end of the current period.
/// * [canceledAt] - If the subscription has been canceled, the date of that cancellation. If the subscription was canceled with ``cancel_at_period_end``, canceled_at will still reflect the date of the initial cancellation request, not the end of the subscription period when the subscription is automatically moved to a canceled state.
/// * [collectionMethod] - Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions.
/// * [currentPeriodEnd] - End of the current period for which the subscription has been invoiced. At the end of this period, a new invoice will be created.
/// * [currentPeriodStart] - Start of the current period for which the subscription has been invoiced.
/// * [daysUntilDue] - Number of days a customer has to pay invoices generated by this subscription. This value will be `null` for subscriptions where `billing=charge_automatically`.
/// * [discount] - Describes the current discount applied to this subscription, if there is one. When billing, a discount applied to a subscription overrides a discount applied on a customer-wide basis.
/// * [endedAt] - If the subscription has ended (either because it was canceled or because the customer was switched to a subscription to a new plan), the date the subscription ended.
/// * [nextPendingInvoiceItemInvoice] - Specifies the approximate timestamp on which any pending invoice items will be billed according to the schedule provided at pending_invoice_item_interval.
/// * [pauseCollection] - If specified, payment collection for this subscription will be paused.
/// * [pendingInvoiceItemInterval] - Specifies an interval for how often to bill for any pending invoice items. It is analogous to calling Create an invoice for the given subscription at the specified interval.
/// * [pendingUpdate] - If specified, pending updates that will be applied to the subscription once the latest_invoice has been paid.
/// * [prorationBehavior] 
/// * [prorationDate] - If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply exactly the same proration that was previewed with upcoming invoice endpoint. It can also be used to implement custom proration logic, such as prorating by day instead of by second, by providing the time that you wish to use for proration calculations
/// * [quantity] - The quantity applied to this subscription. This value will be `null` for multi-plan subscriptions
/// * [startDate] - Date when the subscription was first created. The date might differ from the created date due to backdating.
/// * [status] - The status of this subscription.
/// * [trialEnd] - If the subscription has a trial, the end of that trial.
/// * [trialStart] - If the subscription has a trial, the beginning of that trial.
/// * [djstripeOwnerAccount] - The Stripe Account this object belongs to.
/// * [customer] - The customer associated with this subscription.
/// * [defaultPaymentMethod] - The default payment method for the subscription. It must belong to the customer associated with the subscription. If not set, invoices will use the default payment method in the customer's invoice settings.
/// * [defaultSource] - The default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If not set, defaults to the customer's default source.
/// * [latestInvoice] - The most recent invoice this subscription has generated.
/// * [pendingSetupIntent] - We can use this SetupIntent to collect user authentication when creating a subscription without immediate payment or updating a subscription's payment method, allowing you to optimize for off-session payments.
/// * [schedule] - The schedule associated with this subscription.
/// * [defaultTaxRates] - The tax rates that will apply to any subscription item that does not have tax_rates set. Invoices created will have their default_tax_rates populated from the subscription.
abstract class PatchedDJSubscriptions implements Built<PatchedDJSubscriptions, PatchedDJSubscriptionsBuilder> {
    @BuiltValueField(wireName: r'djstripe_id')
    int? get djstripeId;

    @BuiltValueField(wireName: r'plan')
    DJSubscriptionsPlan? get plan;

    @BuiltValueField(wireName: r'price')
    DJSubscriptionsPrice? get price;

    @BuiltValueField(wireName: r'can_reactivate')
    bool? get canReactivate;

    @BuiltValueField(wireName: r'djstripe_created')
    DateTime? get djstripeCreated;

    @BuiltValueField(wireName: r'djstripe_updated')
    DateTime? get djstripeUpdated;

    @BuiltValueField(wireName: r'id')
    String? get id;

    /// Null here indicates that the livemode status is unknown or was previously unrecorded. Otherwise, this field indicates whether this record comes from Stripe test mode or live mode operation.
    @BuiltValueField(wireName: r'livemode')
    bool? get livemode;

    /// The datetime this object was created in stripe.
    @BuiltValueField(wireName: r'created')
    DateTime? get created;

    /// A set of key/value pairs that you can attach to an object. It can be useful for storing additional information about an object in a structured format.
    @BuiltValueField(wireName: r'metadata')
    String? get metadata;

    /// A description of this object.
    @BuiltValueField(wireName: r'description')
    String? get description;

    /// A positive decimal that represents the fee percentage of the subscription invoice amount that will be transferred to the application owner's Stripe account each billing period.
    @BuiltValueField(wireName: r'application_fee_percent')
    double? get applicationFeePercent;

    /// Determines the date of the first full invoice, and, for plans with `month` or `year` intervals, the day of the month for subsequent invoices.
    @BuiltValueField(wireName: r'billing_cycle_anchor')
    DateTime? get billingCycleAnchor;

    /// Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period.
    @BuiltValueField(wireName: r'billing_thresholds')
    String? get billingThresholds;

    /// A date in the future at which the subscription will automatically get canceled.
    @BuiltValueField(wireName: r'cancel_at')
    DateTime? get cancelAt;

    /// If the subscription has been canceled with the ``at_period_end`` flag set to true, ``cancel_at_period_end`` on the subscription will be true. You can use this attribute to determine whether a subscription that has a status of active is scheduled to be canceled at the end of the current period.
    @BuiltValueField(wireName: r'cancel_at_period_end')
    bool? get cancelAtPeriodEnd;

    /// If the subscription has been canceled, the date of that cancellation. If the subscription was canceled with ``cancel_at_period_end``, canceled_at will still reflect the date of the initial cancellation request, not the end of the subscription period when the subscription is automatically moved to a canceled state.
    @BuiltValueField(wireName: r'canceled_at')
    DateTime? get canceledAt;

    /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions.
    @BuiltValueField(wireName: r'collection_method')
    CollectionMethodEnum? get collectionMethod;

    /// End of the current period for which the subscription has been invoiced. At the end of this period, a new invoice will be created.
    @BuiltValueField(wireName: r'current_period_end')
    DateTime? get currentPeriodEnd;

    /// Start of the current period for which the subscription has been invoiced.
    @BuiltValueField(wireName: r'current_period_start')
    DateTime? get currentPeriodStart;

    /// Number of days a customer has to pay invoices generated by this subscription. This value will be `null` for subscriptions where `billing=charge_automatically`.
    @BuiltValueField(wireName: r'days_until_due')
    int? get daysUntilDue;

    /// Describes the current discount applied to this subscription, if there is one. When billing, a discount applied to a subscription overrides a discount applied on a customer-wide basis.
    @BuiltValueField(wireName: r'discount')
    String? get discount;

    /// If the subscription has ended (either because it was canceled or because the customer was switched to a subscription to a new plan), the date the subscription ended.
    @BuiltValueField(wireName: r'ended_at')
    DateTime? get endedAt;

    /// Specifies the approximate timestamp on which any pending invoice items will be billed according to the schedule provided at pending_invoice_item_interval.
    @BuiltValueField(wireName: r'next_pending_invoice_item_invoice')
    DateTime? get nextPendingInvoiceItemInvoice;

    /// If specified, payment collection for this subscription will be paused.
    @BuiltValueField(wireName: r'pause_collection')
    String? get pauseCollection;

    /// Specifies an interval for how often to bill for any pending invoice items. It is analogous to calling Create an invoice for the given subscription at the specified interval.
    @BuiltValueField(wireName: r'pending_invoice_item_interval')
    String? get pendingInvoiceItemInterval;

    /// If specified, pending updates that will be applied to the subscription once the latest_invoice has been paid.
    @BuiltValueField(wireName: r'pending_update')
    String? get pendingUpdate;

    @BuiltValueField(wireName: r'proration_behavior')
    DJSubscriptionsProrationBehavior? get prorationBehavior;

    /// If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply exactly the same proration that was previewed with upcoming invoice endpoint. It can also be used to implement custom proration logic, such as prorating by day instead of by second, by providing the time that you wish to use for proration calculations
    @BuiltValueField(wireName: r'proration_date')
    DateTime? get prorationDate;

    /// The quantity applied to this subscription. This value will be `null` for multi-plan subscriptions
    @BuiltValueField(wireName: r'quantity')
    int? get quantity;

    /// Date when the subscription was first created. The date might differ from the created date due to backdating.
    @BuiltValueField(wireName: r'start_date')
    DateTime? get startDate;

    /// The status of this subscription.
    @BuiltValueField(wireName: r'status')
    StatusEnum? get status;

    /// If the subscription has a trial, the end of that trial.
    @BuiltValueField(wireName: r'trial_end')
    DateTime? get trialEnd;

    /// If the subscription has a trial, the beginning of that trial.
    @BuiltValueField(wireName: r'trial_start')
    DateTime? get trialStart;

    /// The Stripe Account this object belongs to.
    @BuiltValueField(wireName: r'djstripe_owner_account')
    int? get djstripeOwnerAccount;

    /// The customer associated with this subscription.
    @BuiltValueField(wireName: r'customer')
    int? get customer;

    /// The default payment method for the subscription. It must belong to the customer associated with the subscription. If not set, invoices will use the default payment method in the customer's invoice settings.
    @BuiltValueField(wireName: r'default_payment_method')
    int? get defaultPaymentMethod;

    /// The default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If not set, defaults to the customer's default source.
    @BuiltValueField(wireName: r'default_source')
    String? get defaultSource;

    /// The most recent invoice this subscription has generated.
    @BuiltValueField(wireName: r'latest_invoice')
    int? get latestInvoice;

    /// We can use this SetupIntent to collect user authentication when creating a subscription without immediate payment or updating a subscription's payment method, allowing you to optimize for off-session payments.
    @BuiltValueField(wireName: r'pending_setup_intent')
    int? get pendingSetupIntent;

    /// The schedule associated with this subscription.
    @BuiltValueField(wireName: r'schedule')
    int? get schedule;

    /// The tax rates that will apply to any subscription item that does not have tax_rates set. Invoices created will have their default_tax_rates populated from the subscription.
    @BuiltValueField(wireName: r'default_tax_rates')
    BuiltList<int>? get defaultTaxRates;

    PatchedDJSubscriptions._();

    @BuiltValueHook(initializeBuilder: true)
    static void _defaults(PatchedDJSubscriptionsBuilder b) => b;

    factory PatchedDJSubscriptions([void updates(PatchedDJSubscriptionsBuilder b)]) = _$PatchedDJSubscriptions;

    @BuiltValueSerializer(custom: true)
    static Serializer<PatchedDJSubscriptions> get serializer => _$PatchedDJSubscriptionsSerializer();
}

class _$PatchedDJSubscriptionsSerializer implements StructuredSerializer<PatchedDJSubscriptions> {
    @override
    final Iterable<Type> types = const [PatchedDJSubscriptions, _$PatchedDJSubscriptions];

    @override
    final String wireName = r'PatchedDJSubscriptions';

    @override
    Iterable<Object?> serialize(Serializers serializers, PatchedDJSubscriptions object,
        {FullType specifiedType = FullType.unspecified}) {
        final result = <Object?>[];
        if (object.djstripeId != null) {
            result
                ..add(r'djstripe_id')
                ..add(serializers.serialize(object.djstripeId,
                    specifiedType: const FullType(int)));
        }
        if (object.plan != null) {
            result
                ..add(r'plan')
                ..add(serializers.serialize(object.plan,
                    specifiedType: const FullType(DJSubscriptionsPlan)));
        }
        if (object.price != null) {
            result
                ..add(r'price')
                ..add(serializers.serialize(object.price,
                    specifiedType: const FullType(DJSubscriptionsPrice)));
        }
        if (object.canReactivate != null) {
            result
                ..add(r'can_reactivate')
                ..add(serializers.serialize(object.canReactivate,
                    specifiedType: const FullType(bool)));
        }
        if (object.djstripeCreated != null) {
            result
                ..add(r'djstripe_created')
                ..add(serializers.serialize(object.djstripeCreated,
                    specifiedType: const FullType(DateTime)));
        }
        if (object.djstripeUpdated != null) {
            result
                ..add(r'djstripe_updated')
                ..add(serializers.serialize(object.djstripeUpdated,
                    specifiedType: const FullType(DateTime)));
        }
        if (object.id != null) {
            result
                ..add(r'id')
                ..add(serializers.serialize(object.id,
                    specifiedType: const FullType(String)));
        }
        if (object.livemode != null) {
            result
                ..add(r'livemode')
                ..add(serializers.serialize(object.livemode,
                    specifiedType: const FullType.nullable(bool)));
        }
        if (object.created != null) {
            result
                ..add(r'created')
                ..add(serializers.serialize(object.created,
                    specifiedType: const FullType.nullable(DateTime)));
        }
        if (object.metadata != null) {
            result
                ..add(r'metadata')
                ..add(serializers.serialize(object.metadata,
                    specifiedType: const FullType.nullable(String)));
        }
        if (object.description != null) {
            result
                ..add(r'description')
                ..add(serializers.serialize(object.description,
                    specifiedType: const FullType.nullable(String)));
        }
        if (object.applicationFeePercent != null) {
            result
                ..add(r'application_fee_percent')
                ..add(serializers.serialize(object.applicationFeePercent,
                    specifiedType: const FullType.nullable(double)));
        }
        if (object.billingCycleAnchor != null) {
            result
                ..add(r'billing_cycle_anchor')
                ..add(serializers.serialize(object.billingCycleAnchor,
                    specifiedType: const FullType.nullable(DateTime)));
        }
        if (object.billingThresholds != null) {
            result
                ..add(r'billing_thresholds')
                ..add(serializers.serialize(object.billingThresholds,
                    specifiedType: const FullType.nullable(String)));
        }
        if (object.cancelAt != null) {
            result
                ..add(r'cancel_at')
                ..add(serializers.serialize(object.cancelAt,
                    specifiedType: const FullType.nullable(DateTime)));
        }
        if (object.cancelAtPeriodEnd != null) {
            result
                ..add(r'cancel_at_period_end')
                ..add(serializers.serialize(object.cancelAtPeriodEnd,
                    specifiedType: const FullType(bool)));
        }
        if (object.canceledAt != null) {
            result
                ..add(r'canceled_at')
                ..add(serializers.serialize(object.canceledAt,
                    specifiedType: const FullType.nullable(DateTime)));
        }
        if (object.collectionMethod != null) {
            result
                ..add(r'collection_method')
                ..add(serializers.serialize(object.collectionMethod,
                    specifiedType: const FullType.nullable(CollectionMethodEnum)));
        }
        if (object.currentPeriodEnd != null) {
            result
                ..add(r'current_period_end')
                ..add(serializers.serialize(object.currentPeriodEnd,
                    specifiedType: const FullType(DateTime)));
        }
        if (object.currentPeriodStart != null) {
            result
                ..add(r'current_period_start')
                ..add(serializers.serialize(object.currentPeriodStart,
                    specifiedType: const FullType(DateTime)));
        }
        if (object.daysUntilDue != null) {
            result
                ..add(r'days_until_due')
                ..add(serializers.serialize(object.daysUntilDue,
                    specifiedType: const FullType.nullable(int)));
        }
        if (object.discount != null) {
            result
                ..add(r'discount')
                ..add(serializers.serialize(object.discount,
                    specifiedType: const FullType.nullable(String)));
        }
        if (object.endedAt != null) {
            result
                ..add(r'ended_at')
                ..add(serializers.serialize(object.endedAt,
                    specifiedType: const FullType.nullable(DateTime)));
        }
        if (object.nextPendingInvoiceItemInvoice != null) {
            result
                ..add(r'next_pending_invoice_item_invoice')
                ..add(serializers.serialize(object.nextPendingInvoiceItemInvoice,
                    specifiedType: const FullType.nullable(DateTime)));
        }
        if (object.pauseCollection != null) {
            result
                ..add(r'pause_collection')
                ..add(serializers.serialize(object.pauseCollection,
                    specifiedType: const FullType.nullable(String)));
        }
        if (object.pendingInvoiceItemInterval != null) {
            result
                ..add(r'pending_invoice_item_interval')
                ..add(serializers.serialize(object.pendingInvoiceItemInterval,
                    specifiedType: const FullType.nullable(String)));
        }
        if (object.pendingUpdate != null) {
            result
                ..add(r'pending_update')
                ..add(serializers.serialize(object.pendingUpdate,
                    specifiedType: const FullType.nullable(String)));
        }
        if (object.prorationBehavior != null) {
            result
                ..add(r'proration_behavior')
                ..add(serializers.serialize(object.prorationBehavior,
                    specifiedType: const FullType(DJSubscriptionsProrationBehavior)));
        }
        if (object.prorationDate != null) {
            result
                ..add(r'proration_date')
                ..add(serializers.serialize(object.prorationDate,
                    specifiedType: const FullType.nullable(DateTime)));
        }
        if (object.quantity != null) {
            result
                ..add(r'quantity')
                ..add(serializers.serialize(object.quantity,
                    specifiedType: const FullType.nullable(int)));
        }
        if (object.startDate != null) {
            result
                ..add(r'start_date')
                ..add(serializers.serialize(object.startDate,
                    specifiedType: const FullType.nullable(DateTime)));
        }
        if (object.status != null) {
            result
                ..add(r'status')
                ..add(serializers.serialize(object.status,
                    specifiedType: const FullType.nullable(StatusEnum)));
        }
        if (object.trialEnd != null) {
            result
                ..add(r'trial_end')
                ..add(serializers.serialize(object.trialEnd,
                    specifiedType: const FullType.nullable(DateTime)));
        }
        if (object.trialStart != null) {
            result
                ..add(r'trial_start')
                ..add(serializers.serialize(object.trialStart,
                    specifiedType: const FullType.nullable(DateTime)));
        }
        if (object.djstripeOwnerAccount != null) {
            result
                ..add(r'djstripe_owner_account')
                ..add(serializers.serialize(object.djstripeOwnerAccount,
                    specifiedType: const FullType.nullable(int)));
        }
        if (object.customer != null) {
            result
                ..add(r'customer')
                ..add(serializers.serialize(object.customer,
                    specifiedType: const FullType(int)));
        }
        if (object.defaultPaymentMethod != null) {
            result
                ..add(r'default_payment_method')
                ..add(serializers.serialize(object.defaultPaymentMethod,
                    specifiedType: const FullType.nullable(int)));
        }
        if (object.defaultSource != null) {
            result
                ..add(r'default_source')
                ..add(serializers.serialize(object.defaultSource,
                    specifiedType: const FullType.nullable(String)));
        }
        if (object.latestInvoice != null) {
            result
                ..add(r'latest_invoice')
                ..add(serializers.serialize(object.latestInvoice,
                    specifiedType: const FullType.nullable(int)));
        }
        if (object.pendingSetupIntent != null) {
            result
                ..add(r'pending_setup_intent')
                ..add(serializers.serialize(object.pendingSetupIntent,
                    specifiedType: const FullType.nullable(int)));
        }
        if (object.schedule != null) {
            result
                ..add(r'schedule')
                ..add(serializers.serialize(object.schedule,
                    specifiedType: const FullType.nullable(int)));
        }
        if (object.defaultTaxRates != null) {
            result
                ..add(r'default_tax_rates')
                ..add(serializers.serialize(object.defaultTaxRates,
                    specifiedType: const FullType(BuiltList, [FullType(int)])));
        }
        return result;
    }

    @override
    PatchedDJSubscriptions deserialize(Serializers serializers, Iterable<Object?> serialized,
        {FullType specifiedType = FullType.unspecified}) {
        final result = PatchedDJSubscriptionsBuilder();

        final iterator = serialized.iterator;
        while (iterator.moveNext()) {
            final key = iterator.current as String;
            iterator.moveNext();
            final Object? value = iterator.current;
            
            switch (key) {
                case r'djstripe_id':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType(int)) as int;
                    result.djstripeId = valueDes;
                    break;
                case r'plan':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType(DJSubscriptionsPlan)) as DJSubscriptionsPlan;
                    result.plan.replace(valueDes);
                    break;
                case r'price':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType(DJSubscriptionsPrice)) as DJSubscriptionsPrice;
                    result.price.replace(valueDes);
                    break;
                case r'can_reactivate':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType(bool)) as bool;
                    result.canReactivate = valueDes;
                    break;
                case r'djstripe_created':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType(DateTime)) as DateTime;
                    result.djstripeCreated = valueDes;
                    break;
                case r'djstripe_updated':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType(DateTime)) as DateTime;
                    result.djstripeUpdated = valueDes;
                    break;
                case r'id':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType(String)) as String;
                    result.id = valueDes;
                    break;
                case r'livemode':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(bool)) as bool?;
                    if (valueDes == null) continue;
                    result.livemode = valueDes;
                    break;
                case r'created':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(DateTime)) as DateTime?;
                    if (valueDes == null) continue;
                    result.created = valueDes;
                    break;
                case r'metadata':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(String)) as String?;
                    if (valueDes == null) continue;
                    result.metadata = valueDes;
                    break;
                case r'description':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(String)) as String?;
                    if (valueDes == null) continue;
                    result.description = valueDes;
                    break;
                case r'application_fee_percent':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(double)) as double?;
                    if (valueDes == null) continue;
                    result.applicationFeePercent = valueDes;
                    break;
                case r'billing_cycle_anchor':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(DateTime)) as DateTime?;
                    if (valueDes == null) continue;
                    result.billingCycleAnchor = valueDes;
                    break;
                case r'billing_thresholds':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(String)) as String?;
                    if (valueDes == null) continue;
                    result.billingThresholds = valueDes;
                    break;
                case r'cancel_at':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(DateTime)) as DateTime?;
                    if (valueDes == null) continue;
                    result.cancelAt = valueDes;
                    break;
                case r'cancel_at_period_end':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType(bool)) as bool;
                    result.cancelAtPeriodEnd = valueDes;
                    break;
                case r'canceled_at':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(DateTime)) as DateTime?;
                    if (valueDes == null) continue;
                    result.canceledAt = valueDes;
                    break;
                case r'collection_method':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(CollectionMethodEnum)) as CollectionMethodEnum?;
                    if (valueDes == null) continue;
                    result.collectionMethod = valueDes;
                    break;
                case r'current_period_end':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType(DateTime)) as DateTime;
                    result.currentPeriodEnd = valueDes;
                    break;
                case r'current_period_start':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType(DateTime)) as DateTime;
                    result.currentPeriodStart = valueDes;
                    break;
                case r'days_until_due':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(int)) as int?;
                    if (valueDes == null) continue;
                    result.daysUntilDue = valueDes;
                    break;
                case r'discount':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(String)) as String?;
                    if (valueDes == null) continue;
                    result.discount = valueDes;
                    break;
                case r'ended_at':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(DateTime)) as DateTime?;
                    if (valueDes == null) continue;
                    result.endedAt = valueDes;
                    break;
                case r'next_pending_invoice_item_invoice':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(DateTime)) as DateTime?;
                    if (valueDes == null) continue;
                    result.nextPendingInvoiceItemInvoice = valueDes;
                    break;
                case r'pause_collection':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(String)) as String?;
                    if (valueDes == null) continue;
                    result.pauseCollection = valueDes;
                    break;
                case r'pending_invoice_item_interval':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(String)) as String?;
                    if (valueDes == null) continue;
                    result.pendingInvoiceItemInterval = valueDes;
                    break;
                case r'pending_update':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(String)) as String?;
                    if (valueDes == null) continue;
                    result.pendingUpdate = valueDes;
                    break;
                case r'proration_behavior':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType(DJSubscriptionsProrationBehavior)) as DJSubscriptionsProrationBehavior;
                    result.prorationBehavior.replace(valueDes);
                    break;
                case r'proration_date':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(DateTime)) as DateTime?;
                    if (valueDes == null) continue;
                    result.prorationDate = valueDes;
                    break;
                case r'quantity':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(int)) as int?;
                    if (valueDes == null) continue;
                    result.quantity = valueDes;
                    break;
                case r'start_date':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(DateTime)) as DateTime?;
                    if (valueDes == null) continue;
                    result.startDate = valueDes;
                    break;
                case r'status':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(StatusEnum)) as StatusEnum?;
                    if (valueDes == null) continue;
                    result.status = valueDes;
                    break;
                case r'trial_end':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(DateTime)) as DateTime?;
                    if (valueDes == null) continue;
                    result.trialEnd = valueDes;
                    break;
                case r'trial_start':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(DateTime)) as DateTime?;
                    if (valueDes == null) continue;
                    result.trialStart = valueDes;
                    break;
                case r'djstripe_owner_account':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(int)) as int?;
                    if (valueDes == null) continue;
                    result.djstripeOwnerAccount = valueDes;
                    break;
                case r'customer':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType(int)) as int;
                    result.customer = valueDes;
                    break;
                case r'default_payment_method':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(int)) as int?;
                    if (valueDes == null) continue;
                    result.defaultPaymentMethod = valueDes;
                    break;
                case r'default_source':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(String)) as String?;
                    if (valueDes == null) continue;
                    result.defaultSource = valueDes;
                    break;
                case r'latest_invoice':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(int)) as int?;
                    if (valueDes == null) continue;
                    result.latestInvoice = valueDes;
                    break;
                case r'pending_setup_intent':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(int)) as int?;
                    if (valueDes == null) continue;
                    result.pendingSetupIntent = valueDes;
                    break;
                case r'schedule':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType.nullable(int)) as int?;
                    if (valueDes == null) continue;
                    result.schedule = valueDes;
                    break;
                case r'default_tax_rates':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const FullType(BuiltList, [FullType(int)])) as BuiltList<int>;
                    result.defaultTaxRates.replace(valueDes);
                    break;
            }
        }
        return result.build();
    }
}

